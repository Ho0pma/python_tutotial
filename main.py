# ОБЪЕКТЫ В ПИТОНE
import copy

# 1. В питоне, переменные не хранят значения, они ссылаются на объекты, которые хранят значения.
# 2. Момент когда мы присваиваем значение переменной называется ДИНАМИЧЕСКОЙ ТИПИЗАЦИЕЙ, тк именно тогда определяется тип
#    данных

# a = 7   --> создается объект, в котором хранится значение 7, а - это ссылка на объект
# a = 0.4 --> если продублировать, и сказать ссылайся на новый объект, со значением 0.4 - старый объект, который
#             хранил значение 7, сотрется сборщиком мусора, так как остался без ссылки.

# a = 7   --> a ссылается на объект, который хранит 7. b ссылается на тот же объект, что и a. Итого 1 объект
# b = a

# a = b = c = 0              --> означает, что на объект со значением 0 ведут 3 ссылки.
# print(id(a), id(b), id(c)) --> покажет, что у всех один и тот же id

# обмен значениями или МНОЖЕСТВЕННОЕ ПРИСВАИВАНИЕ:
# a, b = 1, 2  --> a ссылается на объект со значением 1, b ссылается на объект со значением 2
# a, b = b, a  --> a ссылается на объект, на который ссылается b, b ссылается на объект, на который ссылается а.
#                  После этого появляются новые ссылки a и b.

# a = 2 + 3    --> создается два объекта, значения этих объектов складываются, формируется третий объект с суммирован-
#                  ным значением. После этого для переменной а создается ссылка на последний объект. Первые два удаляются
#                  сборщиком мусора

# -------------------------------------------------------------------------------------------------------------------- #
# ЦЕЛОЧИСЛЕННОЕ ДЕЛЕНИЕ (округление к наименьшему целому)

# print(7 // 2)   --> 3
# print(7 // -2)  --> -4
# print(-7 // 2)  --> -4 (тк будет -3.5, округление к меньшему т.е. к -4)
# print(-7 // -2) --> 3

# -------------------------------------------------------------------------------------------------------------------- #
# ОСТАТОК ОТ ДЕЛЕНИЯ

# print(9 % 5)   --> 4
# print(-9 % 5)  --> ближайшее кратное число минус число, которое хотим делить (-10) - (-9) = 1
# print(9 % -5)  --> 1
# print(-9 % -5) --> -4

# -------------------------------------------------------------------------------------------------------------------- #
# ВОЗВЕДЕНИЕ В СТЕПЕНЬ

# print(2 ** 3 ** 2) --> справа на лево т.е. сначала 3 ** 2, потом 2 ** 9
# print(27 ** 1/3)   --> 9 (тк приоритет возведения в степень выше чем у деления)

# -------------------------------------------------------------------------------------------------------------------- #
# МАТЕМАТИЧЕСКИЕ ФУНКЦИИ, которые я наиболее часто использую

# abs(x):        --> Возвращает абсолютное значение числа x.
# pow(x, y):     --> Возвращает x в степени y.
# round(x):      --> Округляет число x до ближайшего целого числа.
# max(iterable): --> Возвращает наибольший элемент из итерируемого объекта.
# min(iterable): --> Возвращает наименьший элемент из итерируемого объекта.
# sum(iterable): --> Возвращает сумму элементов из итерируемого объекта.
# sqrt(x):       --> Возвращает квадратный корень из числа x.

# -------------------------------------------------------------------------------------------------------------------- #
# ФОРМАТЫ ПРЕДСТАВЛЕНИЯ ЧИСЕЛ / <число>e<целая степень десятки>

# экспоненциальная запись числа
# s = 5e2  # тоже самое, что и 5 * 10^2 = 500
# s = 1e-2 # 1 * 10^-2 = 0.01
# print(s) # выведет 0.01

# СИСТЕМЫ СЧИСЛЕНИЯ

# Десятеричная
# a = 123 # 123 = 1 * 10^2 + 2 * 10^1 + 3 * 10^0

# двоичная
# a = 001 # 123 = 0 * 2^2 + 0 * 2^1 + 1 * 2^0 = 1

# чтобы прописать в питоне в двоичной записи и не выдавало ошибок
# print(0b001)   #--> выведет 1
# print(0b1101)  #--> выведет 13
# print(-0b1101) #--> выведет -13

# преобразовать 10 в 2
# print(bin(13)) #--> 0b1101

# Шестнацетиричная 0 - 9, A, B, C, D, E, F
# 1A = 1 * 16^1 + A * 16^0 = 26

# чтобы прописать в питоне в 16ричной записи числа
# print(0x1A)    #--> 26


# Восьмеричная 8: 0 - 7
# 27 = 2 * 8^1 + 7 * 8^0 = 23
# print(0o27)    #--> 23

# -------------------------------------------------------------------------------------------------------------------- #
# БИТОВЫЕ ОПЕРАЦИИ

# ПРИОРИТЕТЫ (1(ИЛИ) 1(XOR) 2(И) 3(НЕ)) - 3 самый высокий

# если двоичное число вначале равно 0 - положительное, 1 - отрицательное
# ~ - означает инвертировать
# если проинвертировать 0, то будет -1

# БИТОВАЯ ОПЕРАЦИЯ НЕ (~)
# таблица
# x1 ~
# 1  0
# 0  1

# print(~121) #--> - 122
# print(~0)   #--> -1
# print(~10)  #--> -11
# print(~-10) #--> 9

# БИТОВАЯ ОПЕРАЦИЯ И (&)
# таблица
# x1 x2 &
# 0  0  0
# 0  1  0
# 1  0  0
# 1  1  1

# print(bin(5))
# print(bin(4))

# чтобы сделать операцию & для этих чисел - нужно вычислить каждые пары чисел согласно таблице истинности
# типа 0 & 0 и тд
# 7 6 5 4 3 2 1 0  --> порядок бит
# 0 0 0 0 0 1 0 1  --> 5 (переменная flags)
# 0 0 0 0 0 1 0 0  --> 4 (переменная mask)
# 0 0 0 0 0 1 0 0  --> 4 (result)

# в итоге получим 0 0 0 0 0 1 0 0, что равно 4
# print(5 & 4) #--> 4

# А зачем это все надо?
# Задача: узнать включен ли второй бит у переменной flags?
# делаем это с помощью вспомогательной переменной mask (эту переменную нужно создать таким образом, чтобы все
# было 0, кроме 2го бита числа, те как у нас 0 0 0 0 0 1 0 0
# Тогда при побитовом умножении flags&mask, если у flags значения бита будет - 0, результат будет 0, а если 1 - 1
# это говорит о том, что бит равный 1 у переменной mask будет в точно сохранять значение бита, который мы пытаемся
# умножить (смотри таблицу)

# задача: проверить включен ли бит
# flags = 1          #--> 001  / если тут поставить к примеру 5 (те 101) тогда будет 1 на втором бите
# print(bin(flags))
# mask = 4           #--> 100
# print(bin(mask))
#
# if flags & mask == mask:
#     print('Второй бит включен')
# else:
#     print('Второй бит выключен')


# Выключение битов числа
# flags = 13
# print(bin(flags))   #--> 1101
# mask = 5
# print(bin(mask))    #--> 0101
# res = flags & ~mask #--> в этой записи наибольший приоритет имеет инверсия (~), потом идет побитовое И (&)
# mask будет записан в виде 1 1 1 1 1 0 1 0 (там где были 0 - стали 1)
# как мы уже знаем, если у второй переменной mask бит равен единице, то при побитовом умножении (&) c первым числом -
# она будет сохранять значения бита первой переменной

# 7 6 5 4 3 2 1 0  --> порядок бит
# 0 0 0 0 1 1 0 1  --> 13 (переменная flags)
# 1 1 1 1 1 0 1 0  --> 5 (переменная mask)
# 0 0 0 0 1 0 0 0  --> 8 (result)   # при таком исходе второй бит выключится


# БИТОВАЯ ОПЕРАЦИЯ ИЛИ (|)
# x1 x2 |
# 0  0  0
# 0  1  1
# 1  0  1
# 1  1  1

# обычно используют, чтобы включить отдельные биты числа

# flags = 8
# mask = 5
# flags = flags | mask
# print(flags)         #--> 13

# 7 6 5 4 3 2 1 0  --> порядок бит
# 0 0 0 0 1 0 0 0  --> 8 (переменная flags)
# 0 0 0 0 0 1 0 1  --> 5 (переменная mask)
# 0 0 0 0 1 1 0 1  --> 13 (result)

# тем самым мы включили второй и нулевой биты переменной flags

# БИТОВАЯ ОПЕРАЦИЯ XOR(^)
# x1 x2 ^
# 0  0  0
# 0  1  1
# 1  0  1
# 1  1  0  <-- где две ед тоже 0

# удобен для ПЕРЕКЛЮЧЕНИЯ битов (внимание на вторую и третью строку таблицы)
# переключим нулевой бит
# flags = 9
# mask = 1
# flags = flags ^ mask
# print(flags) # 8

# 7 6 5 4 3 2 1 0  --> порядок бит
# 0 0 0 0 1 0 0 1  --> 9 (переменная flags)
# 0 0 0 0 0 0 0 1  --> 1 (переменная mask)
# 0 0 0 0 1 0 0 0  --> 8 (result)

# тем самым выключили нулевой бит
# МОМЕНТ! Если выполнить в программе flags = flags ^ mask еще раз, то бит включится (без потери данных)

# СМЕЩЕНИЕ БИТА
# x = 160
# print(bin(x)) #--> 10100000
# x = x >> 1    #--> будет равно 80
# print(bin(x)) #--> 01010000

#--> можно сделать вывод, что побитовый сдвиг вправо делит исходное число на 2
#    если сдвинем на 2

# x = x >> 2 #--> то разделим на 4 и получим (80 / 4 = 20)
# print(x)
# x = x >> 2 #--> еще раз на разделим на 4 получим 5
# print(x)
# x = x >> 1 #--> если 5 сдвинуть на 1 бит, то это будет эквивалентно округлению, получим 2
# print(x)

#--> при сдвигании бита влево - будет умножение

# 1 включить бит
# n = int(input())
# print(0b11010001)
# print(bin(100)) #--> 1100100
# print(bin(108)) #--> 0001000
#                 #--> 1101100 # 8
# print(0b1100100|0b0001000)

# 2 выключить бит
# number = int(input("Введите число: "))
#
# # Маска с выключенными 4-м и 1-м битами
# mask = ~(1 << 4) & ~(1 << 1)
#
# result = number & mask
#
# print(result)

# # 3
# number = int(input("Введите число: "))
#
# # Маска с переключенными 3-м и 0-м битами
# mask = (1 << 3) ^ (1 << 0)
#
# result = number ^ mask
#
# print(result)

# 4
# n = int(input())
# print(n << 2 )

# 5 расшифровка слова
# encrypted_word = input("Введите зашифрованное слово: ")
# key = 123
#
# decrypted_word = ""
#
# for char in encrypted_word:
#     decrypted_char = chr(ord(char) ^ key)
#     decrypted_word += decrypted_char
#
# print(decrypted_word)

# 6
# проверка включены ли биты 6 и 3
# number = int(input("Введите число: "))

# Маска с включенными 6-м и 3-м битами
# mask = (1 << 6) | (1 << 3)
#
# result = number & mask
#
# if result == mask:
#     print("ДА")
# else:
#     print("НЕТ")

# -------------------------------------------------------------------------------------------------------------------- #
# МОДУЛЬ RANDOM

# import random

# тут предоставлены все функции, которые работают при РАВНОМЕРНОМ законе распределения (одинаковая вероятность)
# print(random.random())             #--> рандомное число
# print(random.uniform(1, 5))        #--> рандомное число в диапазоне от 1 до 5
# print(random.randint(-3, 7))       #--> рандомное интовое число от -3 до 7
# print(random.randrange(-2, 10, 2)) #--> рандомное число от -2 до 10 с шагом два (по сути только четные)
#
# есть еще ГАУССОВСКИЙ закон распределения (он встречается в жизни гораздо чаще). Суть в том, что есть среднее значение
# (мат. ожидание) которое должно выпадать чаще чем другие. Чем ближе к нему - тем выше вероятность. Чем дальше - тем меньше

# print(random.gauss(0, 3.5))        #-->  0 - мат ожидание, 3.5 - мера разброса
#
# lst = [4, 5, 0, -1, 10, 76, 3]
# print(random.choice(lst))          #--> рандомное число из lst
# print(random.shuffle(lst))         #--> перемешивает список, работает только с изменяемыми типами данных. Меняется сам список lst
# print(random.sample(lst, 3))       #--> новый список из неповторяющихся элeментов, 3 - сколько нужно выбрать элементов
#
# чтобы генерировать рандомные последовательности, но при повторном вызове они не менялись нужно использовать
# random.seed(1) # 1 - Это просто число, типо это зерно (ключ) - не менять

# -------------------------------------------------------------------------------------------------------------------- #
# MATCH / CASE

# Помогает анализировать переменные на соответствие шаблонам. По сути это то же самое что и If/elif/else, но с
# большей вариативностью и читабельностью кода

# пример 1
# cmd = 'top'
#
# match cmd:                        #--> найдет соответствие - отработает один кейс - пропустит все другие кейсы
#     case 'top':                   #-->'top' - это шаблон проверки, в данном случае - константа
#         print('вверх')
#     case 'left' | 'little_left':  #--> если нужно учесть несколько констант
#         print('влево')
#     case 'right':
#         print('вправо')
#     case _:                       #--> отбойник, сюда попадет если ни один из других кейсов не отработал
#         print('другое')
#
# print('Проверка завершена')

# пример 2
# cmd = 'right'
#
# match cmd:
#     case command:                 #--> command ссылается то же самое значение, что и cmd (будет всегда срабатывать)
#         print(f'Команда: {command}')

# пример 3 / является ли переменная строкой
# --> все шаблоны проверяются слева направо!
# cmd = 1
# match cmd:
#     case str() as command:                      #--> сначала идет проверка, что cmd строка или нет, если это так, то создается
#         print(f'str Команда: {command}')        #--> переменная command, которая ссылается на то же самое, что и cmd
#     case bool() as command:                     #--> бул должен идти до проверки инта, тк бул наследуется от инта и если поставить
#         print(f'bool Команда: {command}')       #--> наоборот, то при проверки True будет выводить кейс с интом
#     case int() as command if 0 <= command <= 9: #--> доп проверка
#         print(f'int Команда: {command}')
#     case _: # wildcard
#         print('Ops')

# задача: вывести команду
# cmd = input().lower()
# match cmd:
#     case 'top' | 'bottom' | 'right' | 'left':
#         print(f'Команда {cmd}')

# -------------------------------------------------------------------------------------------------------------------- #
# MATCH / CASE С КОЛЛЕКЦИЯМИ ДАННЫХ

# cmd = ('lol', 'kek', 1488)         #--> не важно кортеж это или список
#
# match cmd:
#     case arg1, agr2, arg3:         #--> переменные ссылаются на то же, что и cmd (на кортеж) и происходит распаковка
#         print(f'{arg1}, {agr2}, {arg3}')

# естественно, если в кортеже будет больше 3х элементов - кейс не будет срабатывать, чтобы работало нужно:
# cmd = ('lol', 'kek', 1488)
#
# match cmd:
#     # данные скобки нужны только, чтобы визуально было понятно что распаковывается, можно и без них
#     case (str() as arg1, str() as agr2, int() | float()  as arg3, *_) if len(cmd) < 5: #--> все оставшиеся элементы будут запихиваться в *_
#         print(f'{arg1}, {agr2}, {arg3}')

# как сделать обработку данных, если может поступать несколько правильных форматов, к примеру
# cmd = ('Санек', 'Питончик', 555)
# cmd = [1, 'Санек', 'Питончик', 555, 234.1]
#
#--> первый варик - написать два шаблона. Рабочий, выводит одно и то же, но есть дублирование кода
# match cmd:
#     case (name, language, price):
#         print(f'First: {name}, {language}, {price}')
#     case (_, name, language, price, _): # _ - означает, что нам эта переменная не нужна
#         print(f'Second: {name}, {language}, {price}')


# чтобы дублирование не было - нужно объединить эти кейсы в один
# cmd = ('Санек', 'Питончик', 555)
# cmd = [1, 'Санек', 'Питончик', 555, 234.1]
#
# match cmd:
#     # должно быть одинаковое кол-во переменных в обоих шаблонах ( _ - не считается)
#     case (name, language, price) | (_, name, language, price, _):
#         print(f'Both: {name}, {language}, {price}')

# -------------------------------------------------------------------------------------------------------------------- #
# MATCH / CASE с СВЛОВАРЯМИ И МНОЖЕСТВАМИ

# 1
# request = {'url': 'https//', 'method': 'GET', 'timeout': 1000}

# match request:
#     case {'url': url, 'method': method}:              #--> тут фигурные скобки имеют роль, воспринимается, что должен передаться
#         print(f'Запрос url: {url}, method: {method}') #--> словарь с двумя ключами url и method
#     case _:
#         print('Неверный запрос')

# но! наличие других ключей - не играет роли для первого кейса. Главное чтобы были те два ключа, которые написаны в
# кейсе

# 2
# request = {'url': 'https//', 'method': 'GET', 'timeout': 1000}
#
# match request:
#     case {'url': str(url), 'method': str(method)}: # так же проверка что значения ключей должны быть строки
#         print(f'Запрос url: {url}, method: {method}')
#     case _:
#         print('Неверный запрос')

# 3
# request = {'url': 'https//', 'method': 'GET', 'timeout': 1000}
#
# match request:
#     case {'url': str(url), 'method': str(method), 'timeout': 1000}: # проверка что ключ timeout имеет значение 1000
#         print(f'Запрос url: {url}, method: {method}')
#     case _:
#         print('Неверный запрос')

# 4
# request = {'url': 'https//', 'method': 'GET', 'timeout': 1000}
#
# match request:
#     case {'url': str(url), 'method': str(method)} if len(request) <= 3: # проверка длины словаря (не больше 3х ключей)
#         print(f'Запрос url: {url}, method: {method}')
#     case _:
#         print('Неверный запрос')

# 5
# request = {'url': 'https//', 'method': 'GET', 'timeout': 1000, 'new': 1, 'new2': 2}
#
# match request:
#     case {'url': str(url), 'method': str(method), **kwargs} if len(kwargs) <= 2:  #по мимо двух первых ключей, в словаре
#         print(f'Запрос url: {url}, method: {method}')                       # еще может быть не более двух ключей
#     case _:
#         print('Неверный запрос')

# 6
# json_data = {'id': 2, 'type': 'list', 'data': [1, 2, 3], 'access': True}
#
# match json_data:
#     case {'id': id, 'type': 'list', 'data': list() as lst}: # проверка является ли значение словаря листом
#         print(f'json_data: type: list, {lst}')
#     case _:
#         print('Неверный запрос')

# 7
# json_data = {'id': 2, 'access': True, 'info': ['01.02.03', {'login': '123', 'email': '@'}, True, False]}
#
# match json_data:
#     case {'access': access, 'info': [_, {'email': email}, *_]}: # есть ли внутри словаря ключ email, внутри которого
#         print(f'json_data: access: {access}, email: {email}')   # есть ключ email
#     case _:
#         print('Неверный запрос')

# как работать с множествами?
# primary_keys = {1, 2, 3}
#
# match primary_keys:
#     case set() as keys: # {} - не проканает, тк он будет думать что проверяется словарь
#         print(f'primary_keys: {keys}')
#     case _:
#         print('Неверный запрос')

# -------------------------------------------------------------------------------------------------------------------- #
# ФУНКЦИЯ MAP(функция, iterable)
# функцию нужно передавать, но не вызывать, т.е. без ()

# n1, n2, n3 = map(int, input().split())   --> присвоить переменным n1, n2, n3 интовые значения полученные из map
# s1, s2 = map(str.strip, input().split()) --> присвоит значениям s1, s2 строковые значения из map (лишние пробелы
#                                              удалятся функцией strip()

# print(sum([i for i in map(int,input().split()) if i % 2 != 0])) #--> просуммировать все нечетные числа в списке

# -------------------------------------------------------------------------------------------------------------------- #
# МАТЕМАТИЧЕСКИЙ МЕТОД __import__

# print(__import__('math').pi)                  --> импортирует из модуля math функцию pi
# print(__import__('math').trunc(float(input()) --> импортирует из модуля math функцию trunc(), которая оставляет целое

# -------------------------------------------------------------------------------------------------------------------- #

# LIST COMPREHENSION

# int_lst = [int(i) for i in input().split()] --> получить интовый список

# abs_float_lst = [abs(float(i)) for i in input().split()] --> получить список, состоящий из  положительных float чисел

# s1, s2, *_ = [i for i in input().split()]   --> присвоить значения для переменных s1, s2 первые два значения из ввода
#                                                 все остальные значения занесутся в список _

# n = 3                                       --> тоже самое, только ввод будет идти не через пробел, а через каждый
# s1, s2, *_ = [input() for _ in range(n)]        с новой строки

# 4.1 два генератора
# lst_in = ['8 11 -5', '3 4 10', '-1 -2 3', '4 5 6']
# m = [[int(i) for i in x.split()] for x in lst_in]
# print(m)
#
# 4.2 генератор в map # тут еще [*map] = list()
# lst_in = ['8 11 -5', '3 4 10', '-1 -2 3', '4 5 6']
# m = [*map(lambda x: [int(i) for i in x.split()], lst_in)]
# print(m)
#
# 4.3 map()  в генераторе
# lst_in = ['8 11 -5', '3 4 10', '-1 -2 3', '4 5 6']
# m = [[*map(int, x.split())] for x in lst_in]
# print(m)

# задача:
# s = 'house=дом car=машина men=человек tree=дерево'
# s_lst = s.split()
# tp = [tuple(x.split('=')) for x in s_lst]
# print(*tp)


# -------------------------------------------------------------------------------------------------------------------- #
# ORD
# для того, чтобы посмотреть код символа

# [print(f'Код: {i} = {ord(i)}') for i in input()]  --> покажет код введенного символа

# -------------------------------------------------------------------------------------------------------------------- #
# FORMAT

# * - означает что для всех {} будет выполнено одно и тоже
# print('Переменная a = {}, переменная b = {}'.format(*input().split()))
#
# s = str(input())
# print('Строка: {}. Длина: {}'.format(s, len(s))) --> выведет строку, что ввели и ее длину
#
# n1, n2 = 'LOL', 'OPS'
# print('{0} + {1} = {0}{1}'.format(n1, n2))            --> можно в скобочках указывать индексы
# print('{n1} + {n2} = {n1}{n2}'.format(n1=n1, n2=n2))  --> можно указать название индекса

# -------------------------------------------------------------------------------------------------------------------- #
# СРЕЗЫ []

# s = str(input())[:5]   --> срез первых пяти символов
# print(s[::-1])         --> вывод их в обратном порядке

# print([i for i in input().split()][-1]) #--> вывести последний элемент введенного списка

# s1, s2 = input().split() --> ввод через пробел двух слов, занесение в переменные s1 и s2
# print(s1, s2[:len(s1)])  --> вывод слов ориентированный на длину первого слова

# lst = [1, 2, 3, 4, 5]           --> замена интервала в списке
# lst[2:-1] = ['kek', 'cheburek'] --> 3, 4 - заменятся
# print(lst)

# m = [2, 3, 5, 5, 2, 2, 3, 3, 4, 5, 4, 4]
# print(m[::-1][::2])  #--> сначала выводим список в обратном порядке и сразу делаем вывод списка с шагом 2

# -------------------------------------------------------------------------------------------------------------------- #
# МЕТОДЫ СТРОК

# s = 'purple'
# print(s.upper())
# print(s.lower())
# print(s.count('p'))
# print(s.count('p', 1))         #--> сколько кол раз встречается p начиная с 1 индекса
# print(s.count('p', 1, 3))      #--> сколько кол раз встречается p начиная с 1 индекса по 3
# print(s.find('pur'))           #--> выдаст 0 тк такая комбинация символов встречается начиная с 0 индекса
# print(s.find('ff'))            #--> -1 тк нет совпадений
# print(s.find('e'))             #--> 5 индекс
# print(s.rfind('p'))            #--> работает точно так же как и обычный find, только идет теперь справа налево
# print(s.rfind('e'))
# print(s.index('f'))            #--> выдаст ValueError тк не нашел такого значения
# print(s.replace('p', 'G'))     #--> метод меняет все p на G
# print(s.replace('p', ''))      #--> удалит все p
# print(s.replace('p', '', 1))   #--> метод удалит все p, лимит = 1
# print(s.isalpha())             #--> проверят на True / False состоит ли строка из букв
# print('hello mom'.isalpha())   #--> выдаст false тк есть знак пробела
# print('4'.isdigit())           #--> выдаст True тк проверят на True / False состоит ли строка из цифр
# print('4f'.isdigit())          #--> выдаст False
# print('-4.5'.isdigit())        #--> выдаст False тк есть - и .
# print('55'.rjust(4, '0'))      #--> метод создает строку СЛЕВА нулями, если в передаваемая строка меньше четырех символов
# print('33'.ljust(5, ' '))      #--> метод создает строку СПРАВА пробелами
# print('Санек Пенек'.split())   #--> создаст список ['Санек', 'Пенек']
# print(list('Санек Пенек'))     #--> ['С', 'а', 'н', 'е', 'к', ' ', 'П', 'е', 'н', 'е', 'к']
#
# print(', '.join(['1', '2', '3', '4', '5']))  #--> создаст из списка строку разделяя элементы списка сепаратором ', '
# print('        KEK       '.strip())          #--> удалит пробелы
# print(len(input().split()))                  #--> подсчет кол-ва введенных слов

# -------------------------------------------------------------------------------------------------------------------- #
# LIST / СПИСКИ

# print([1, 2, 3] + [4, 5, 6])
# print('Москва' in [i for i in input().split()]) #--> проверяет есть ли слово в списке
# print(sum([3, 3, 2, 4, 4, 5, 4, 3, 2]))         #--> сумма списка. Так же можно использовать MAX / MIN
#
# l = [int(i) for i in input().split()]           #--> вывести среднее значение введенного списка
# print(round(sum(l) / len(l), 1))

# lst = [1, 2, 3, 4, 'f', 'g']
# lst[1] = 'NEW'               #--> присвоить 1 индексу новое значени
# del(lst[5])                  #--> удалить 5 индекс

# -------------------------------------------------------------------------------------------------------------------- #
# МЕТОДЫ СПИСКОВ

# lst = [1, 2, 3, 'gsd', 'gsd', 56, 3, [1, 2, 3]]
# lst.append(4)             #--> добавит значение 4 в конце списка
# lst.insert(2, 'kek')      #--> вставка во второй индекс kek
# lst.remove(3)             #--> удалит первую попавшуюся тройку
# lst.pop()                 #--> удалит последний индекс
# print(lst.pop())          #--> покажет что удалил
# lst.pop(2)                #--> удалит второй индекс
# print(lst.index('gsd'))   #--> выведет первый индекс = введенному значению, если не найдет такое значение - ОШИБКА
# print('gsd' in lst)       #--> проверка есть ли 'gsd' в списке
# print(lst.count('gsd'))   #--> выведет кол-во таких значений в списке
# lst.clear()               #--> очистит список

# -------------------------------------------------------------------------------------------------------------------- #
# ДВУМЕРНЫЕ СПИСКИ

# s1, s2, s3 = [input().split() for i in range(3)] #--> создает три списка
# print([s1, s2, s3])                              #--> заносит их в общий список

# для ввода
# +71234567890 Сергей
# +71234567810 Сергей
# +51234567890 Михаил
# +72134567890 Николай
# lst = [j.split() for j in [input() for i in range(4)]]
# print(lst)
# -------------------------------------------------------------------------------------------------------------------- #

# JOIN

# print(' '.join(['1', '2', '3']))   #--> в джойн подается список-строка
# print(' '.join([1, 2, 3]))         #--> выдаст ошибку, тк в джойн можно передавать только строки

# -------------------------------------------------------------------------------------------------------------------- #
# ТЕРНАРНЫЙ ВИД ОПЕРАТОРА IF

# n = int(input())                                          #--> четное / нечетное
# print(f'{n}: {("четное" if n % 2 == 0 else "нечетное")}')

# n1, n2 = [float(input()) for i in range(2)]               #--> найти максимальное из двух введенных чисел
# print(n1 if n1 > n2 else n2)

# n = int(input())
# print(f'{"кратно" if n % 3 == 0 else "не кратно"} {3}')   #--> узнать кратно ли число 3м

# -------------------------------------------------------------------------------------------------------------------- #
# ALL / ANY

# All - выведет True, если все элементы последовательности - True
# Any - если хотя бы один True
#
# print(all([True, True, True]))                         #--> True
# print(all([True, True, False]))                        #--> False
# print(all([1, 2, 3, True, True]))                      #--> True
# print(all([{1, 2, 3}, [1, 2, 3], 'smth', True, True])) #--> True
# print(all([{}, [], '', False, 0]))                     #--> False  --> если встречается что-то "пустое", типа списка - выдаст False

# задача: найти простые числа в указанном диапазоне
# n = int(input("Введите натуральное число: "))
# primes = [i for i in range(2, n) if all(i % j != 0 for j in range(2, i))]
# print(*primes)

# задача: крестики нолики
# table = ['x', '0', 'x', 'x', '0', '0', 'x', 'x', 'x']
#
# row1 = all(map(lambda x: x == 'x', table[:3]))
# row2 = all(map(lambda x: x == 'x', table[3:6]))
# row3 = all(map(lambda x: x == 'x', table[6:]))
#
# print(row1, row2, row3)

# -------------------------------------------------------------------------------------------------------------------- #
# РЕГУЛЯРКИ / RE

# 22. проверка ввода / правильно ли введен телефон
# import re
#
# phone_number_pattern = r'^\+7\(\d{3}\)\d{3}-\d{2}-\d{2}$' # d - значит digit - цифра
#                                                           # обязательно ^ и $
# number = input()
# if re.match(phone_number_pattern, number): # проверяет совпадает ли одно с другим
#     print('ДА')                            # сначала идет шаблон, потом то что нужно проверить
# else:
#     print('НЕТ')

# убрать из строк пробелы, заменить на -
# import re
#
# n = ['django chto  eto takoe    poryadok ustanovki',
#      'model mtv   marshrutizaciya funkcii  predstavleniya',
#      'marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya'
# ]
#
# for i in n:
#     print(re.sub(r' +', '-', i)) # sub - функция замены (1.что нужно заменить  2. на что поменять 3.где(строка) )
#                                  # + - означает n таких же символов после

# задача: превратить из 'Python - это круто!' --> python-eto-kruto!
# import re
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# def get_str(func):
#     # sub - функция замены (1.что нужно заменить / 2. на что поменять / 3.где(строка) )
#     #  +  - означает n таких же символов после

#     return lambda *args, **kwargs: re.sub('-+', '-', func(*args, **kwargs))
#
# @get_str
# def convert(s):
#     #--> maketrans всегда используется для создания таблицы для метода translate
#     #--> print(dict.fromkeys(': ;.,_', '-')) --> создает словарь, где 1ый арг - ключи, 2ой арг - значение, которое
#                                                  будут принимать ключи
#     #--> str.maketrans(dict) - создает таблицу трансляции, т.е. наш словарь t будет иметь вид не {'ё': 'yo'}, а {1105: 'yo'}
#     #--> {**t, **dict.fromkeys(': ;.,_', '-')}    --> объединение словарей в один
#     #--> translate использует словарь трансляции для перевода передаваемой строки
#     #--> даем строку s - он смотрим есть ли такой ключ в созданной таблице what_need_to_add
#     #--> если есть - меняет, если нет - оставляет как есть. По сути работает как t.get(i, i)

#     what_need_to_add = str.maketrans({**t, **dict.fromkeys(': ;.,_', '-')})
#     return s.lower().translate(what_need_to_add)
#
#
# print(convert('Python - это круто!'))



# -------------------------------------------------------------------------------------------------------------------- #
# DICT / СЛОВАРИ

# вологда=город house=дом True=1 5=отлично 9=божественно
# lst = [j.split('=') for j in [i for i in input().split()]]
# d = dict(lst) # так можно создать словарь на основе двумерного списка

# -------------------------------------------------------------------------------------------------------------------- #
# МЕТОДЫ СЛОВАРЯ

# fromkeys(iter, дефолтное значение) - создает словарь
# lst = [1, 2, 3, 4]
# d = dict.fromkeys(lst, 'kek')
# print(d) # {1: 'kek', 2: 'kek', 3: 'kek', 4: 'kek'}
#
# d2 = d.copy()     #--> копирует словарь
# d.clear()         #--> очищает словарь
#
# print(d2.get(2))                  #--> берет значение по ключу 2
# print(d2.get(5))                  #--> выведет None если такого значения нет
# print(d2.get(5, False))           #--> можно задать другое значение, если такого ключа нет, к примеру False
# print(d2[5])                      #--> отличие от обычно в том, что тут будет error
# print(d2.setdefault(4))           #--> выведет kek
# print(d2.setdefault(5))           #--> выведет None и запишет в d2 5: None
# print(d2.setdefault(6, 'six'))    #--> запишет в d2 6: six
#
# d = {}
# d.setdefault(1, []).append('new value') #--> создаст на месте значения список {1: [new value]}
#
# пример с setdefault
# lst = ['Пушкин: Сказка о рыбаке и рыбке', 'Есенин: Письмо к женщине', 'Тургенев: Муму', 'Пушкин: Евгений Онегин', 'Есенин: Русь']
# lst_new = [i.split(': ') for i in lst]
# d = {}
# for i in lst_new:
#     d.setdefault(i[0], set()).add(i[1])
# print(d)
#
# d2.pop(5)                         #--> удалит ключ 5,  если его нет - выдаст ошибку
# print(d2.pop(5, False))           #--> выведет False
#
# d1 = {1: 'one', 2: 'two', 3: 'three'}
# d2 = {'one': 'one', 2: 'second', 3: 'three'}
#
# d1.update(d2)         #--> обновит d1  значениями из d2, d1 = {1: 'one', 2: 'second', 3: 'three', 'one': 'one'}
# d3 = {**d1, **d2}     #--> объединит словари

# -------------------------------------------------------------------------------------------------------------------- #
# КОРТЕЖИ / TUPLE

# упорядоченная, но неизменяемая коллекция произвольных данных
# ИСПОЛЬЗОВАТЬ когда нужно запретить программисту изменять список
# Кортежи можно перегонять в списки, и списки можно перегонять в кортежи
# кортежи занимают меньше памяти

# объявление
# a = ()
# a = tuple()

# объединение кортежей
# a = ()                    #--> как видно тут мы не добавляем в кортеж, а создаем новый
# a = a + (1,) # a = (1,)

# разбитие по символам
# a = tuple('hello')
# print(a)

# -------------------------------------------------------------------------------------------------------------------- #
# SET / МНОЖЕСТВА
# неупорядоченная коллекция уникальных элементов, по которой можно итерироваться
# в set можно записать только неизменяемые типы данных. List / dict - нельзя
# Так как множества - это неупорядоченная коллекция - нельзя обратиться по индексу типа a[0] не сработает

# определение множества
# b = set()

# a = {1, 2, 3, 'hi', 1, 2, 3}
# print(a) # {1, 2, 3, 'hi'}

# уникальные элементы списка
# print(set([1, 2, 3, 3]))    #--> {1, 2, 3}

# print(set('bfadfabsfbasb')) #--> {'a', 'b', 's', 'd', 'f'}
# print(set(range(6)))        #--> {0, 1, 2, 3, 4, 5}


# a = {1, 2, 3}
# a.add(4)                      #--> add добавляет в множество 1 элемент
# print(a)                      #--> {1, 2, 3, 4}
#
# a.update([1, 2, 3, 4, 'hi'])  #--> добавит в множество несколько элементов, тут можно указывать любой iter объект
# print(a)                      #--> {1, 2, 3, 4, 'hi'}
#
# a.discard(1)                  #--> удалит из множества 1, если такого элемента нет - ничего не произойдет (non error)
# a.remove(2)                   #--> удалит из множества 2, если такого элемента нет - error
# print(a.pop())                #--> удалит из множества первый элемент, print может показать какой именно элемент

# -------------------------------------------------------------------------------------------------------------------- #
# ОПЕРАЦИИ НАД МНОЖЕСТВАМИ

# a = {1, 2, 3}            #--> ЗАПУСКАТЬ НЕ РАЗОМ, А ПО ОТДЕЛЬНОСТИ
# b = {1, 2, 3, 4, 5}
#
# print(a.intersection(b))                     #--> пересечение {1, 2, 3}                               или --> a & b
# a.intersection_update(b)                     #--> сохранит полученные значения в a                    или --> a &= b
# print(a | b)                                 #--> объединение {1, 2, 3, 4, 5}
# a |= b                                       #--> сохранение результата
# print(a.difference(b))                       #--> должно вывести чего нет в b {}                      или --> a - b
# print(b.difference(a))                       #--> должно вывести чего нет в a {4, 5}                  или --> b - a
# print(a.symmetric_difference(b))             #--> выведет несоответствие, в а нет {4, 5}, а в b есть  или --> a ^ b
#
# сравнение множеств
# print({1, 2, 3} == {3, 2, 1})    # True
# print({1, 2, 3} == {3, 2, 1, 4}) # False
# print({1, 2, 3} == {3, 2, 1, 1}) # True
#
# print({1, 2, 3} < {1, 2, 3})     # False
# print({1, 2, 3} < {1, 2, 3, 4})  # True

# -------------------------------------------------------------------------------------------------------------------- #
# FROZEN SET
# frozenset - неизменяемый объект, что означает, что после создания нельзя добавить или удалить элементы.

# frozenset - полезен, когда требуется неизменяемое множество
# которое можно использовать в качестве ключа в словарях или как элемент другого множества.

# print(frozenset([1, 2, 3, 4, 4, 4]))

# -------------------------------------------------------------------------------------------------------------------- #
# ГЕНЕРАТОРЫ

# ГЕНЕРАТОРЫ МНОЖЕСТВ

# s = {i for i in input() if i.isdigit()} #--> уникальные численные значения из введенной строки

# создание множества
# s = {x ** 2 for x in range(5)}
# print(s) # {0, 1, 4, 9, 16}

# ГЕНЕРАТОРЫ СЛОВАРЕЙ

# создание словаря
# s = {x: x ** 2 for x in range(5)}
# print(s) # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# задача: превратить все ключи в заглавные буквы, а значения в int
# d = {'неудовл.': 2, 'удовл.': 3, 'хорошо': 4, 'отлично': 5}
# s = {key.upper(): int(value) for key, value in d.items()}
# print(s)

# задача: убрать ключи 0 и 1
# d = {'лох': 0, 'i': 1, 'неудовл.': '2', 'удовл.': 3, 'хорошо': 4, 'отлично': '5'}
# s = {int(value): key for key, value in d.items() if 2 <= int(value) <= 5}
# print(s)

# задача: распаковка элементов в словарь
# для ввода: 1 ужасно неудовлетворительно удовлетворительно прилично отлично
# start, *names = input().split()
# print(start, names)
# print({key: value for key, value in enumerate(names, start=int(start))})

# посчитать сколько раз встречается 'и' в словаре
# lst = input().lower().split()
# s = {i: lst.count(i) for i in set(lst)}
# print(s.get('и', 0)) # 4

# совместить два словаря
# menu = {'Главная': 'home', 'Архив': 'archive', 'Новости': 'news'}
# lst = ['Города=about-cities', 'Машины=read-of-cars', 'Самолеты=airplanes']
# new_lst = {key: value for key, value in [i.split('=') for i in lst]}       #--> делаем из списка словарь
# print({**menu, **new_lst})


# -------------------------------------------------------------------------------------------------------------------- #
# РАСПАКОВКА ЭЛЕМЕНТОВ

# применяется для любых ИТЕРИРУЕМЫХ ОБЪЕКТОВ

# start, *names = input().split() #--> start - это первый элемент создаваемого списка, names - все оставшееся
# x, y = 1, 2                     #--> можно
# x, y = 1, 2, 3                  #--> нельзя
# x, *y = 1, 2, 3, 4, 5           #--> можно y = [2, 3, 4, 5] x = 1
# *x, y = 1, 2, 3, 4, 5           #--> можно x = [1, 2, 3, 4] y = 5


# a = tuple(-5, 5)
# print(range(a))  #--> ошибка, тк ждет инт значение а не tuple
# print(range(*a)) #--> все гут, тк распаковали range(-5, 5)


# print(*range(*a)) # -5 -4 -3 -2 -1 0 1 2 3 4 #--> распаковали range + tuple
# print([*range(5), *('gfds', 'T', True)])

# распаковка словаря
# d = {1: 'gj', 2: 'good', 3: 'best'}
# print(*d)                             #--> 1 2 3
# print({*d.items()})                   #--> {(1, 'gj'), (2, 'good'), (3, 'best')}
# print({**d})                          #--> тот же словарь

# d1 = {4: 'ahyet'}
# print({**d, **d1})                    #--> совместили два словаря

# -------------------------------------------------------------------------------------------------------------------- #
# ФУНКЦИИ / DEF

# шпаргалка
# def send_mail(ПАРАМЕТР):   #--> те параметр будет ссылаться на объект-аргумент
#     операторы
#
# send_mail(АРГУМЕНТ)

# def func(a, b, c, default=True): #--> a, b, c - называются фактическими параметрами, default - формальным
#     body
# print(func(1, 2, 3, default=1))  #--> 1, 2, 3 - это позиционные аргументы, default=1 - это именованные аргументы

# задача: заключить предложение в нужный тэг
# def get_tag(str, tag='h1'):
#     return f'<{tag}>{str}</{tag}>'
#
# print(get_tag('Работаем с функциями', tag='div'))

# -------------------------------------------------------------------------------------------------------------------- #
# ПРОИЗВОЛЬНОЕ КОЛ-ВО ПАРАМЕТРОВ В ФУНКЦИИ (КАК ФАКТИЧЕСКИХ (args) ТАК И ФОРМАЛЬНЫХ (kwargs))

# def os_path(*args):
#     print(args)                               #--> в args: ('https:\\kek', 'cheburek', 'sex') - кортеж
#     path = '\\'.join(args)
#     return path
#
# p = os_path('https:\\kek', 'cheburek', 'sex') #--> если добавить сюда именованный параметр (sep=True), то будет ошибка
# print(p)

# Чтобы этого избежать и была возможность добавлять ИП:
# def os_path(*args, **kwargs):
#     print(kwargs)                             #--> {'sep': '/', 'trim': True} - словарь
#     path = kwargs['sep'].join(args)
#     return path

# p = os_path('https:\\kek', 'cheburek', 'sex', sep='/', trim=True) #--> но если аргумент sep не передавать, то будет ошибка
# print(p)                                                          #--> тк в словаре kwargs не будет такого ключа, а в коде
#                                                                   #--> взятие ключа sep из kwargs присутствует

# Чтобы этого избежать нужно его указать в параметрах функции ПЕРЕД **kwargs
# def os_path(*args, sep='+', **kwargs):
#     print(kwargs)
#     path = sep.join(args)
#     return path
#
# p = os_path('https:\\kek', 'cheburek', 'sex', trim=True)          #--> тут убрали sep и ошибки нет тк есть формальный параметр
# print(p)

# Чтобы добавлять еще и фактический параметр в функции - нужно прописать его ПЕРЕД *args
# def os_path(disk, *args, sep='+', **kwargs):
#     args = (disk, ) + args   # обновим кортеж
#     path = sep.join(args)
#     return path
#
# p = os_path('F:', '\\kek', 'cheburek', 'sex', trim=True) # тут убрали sep и ошибки нет
# print(p)
#
# Чтобы проверять передали именованный аргумент (trim) и не записывать его в параметрах функции, нужно сделать проверку
# есть ли она kwargs перед его использованием:
# def os_path(disk, *args, sep='+', **kwargs):
#     args = (disk, ) + args                    #--> обновим кортеж (тк у нас ФП передается отдельно, не в args)
#     if 'trim' in kwargs and kwargs['trim']:   #--> проверим есть в kwargs такой ключ и если у него значение
#         args = [x.strip() for x in args]      #--> уберем все пробелы, если они есть в args
#     path = sep.join(args)
#     return path
#
# p = os_path('F:', '\\kek', 'cheb     urek       ', 'sex       ', trim=True) #--> добавили пробелов

# def os_path(disk, *args, sep='+', **kwargs):
#     args = (disk, ) + args
#     if 'trim' in kwargs and kwargs['trim']:   #--> не прошла проверка, тк не передали trim
#         args = [x.strip() for x in args]
#     path = sep.join(args)
#     return path
#
# p = os_path('F:', '\\kek', 'cheb     urek       ', 'sex       ') #--> не захотели передавать аргумент trim вообще
# print(p)                                                         #--> и пробелы все остались

# -------------------------------------------------------------------------------------------------------------------- #
# РЕКУРСИВНЫЕ ФУНКЦИИ

# Самый дефолтный пример
# def recurse(value):
#     print(value, end=' ')
#     if value < 4:
#         recurse(value + 1) #--> дойдет до 4 шага рекурсии и это условие не будет выполняться, тогда функция перепрыгнет
#     print(value, end=' ')  #--> if и дойдет до конца и выведет 4, и начнет возвращаться назад в те функции, которые как
#                            #--> бы выполнила наполовину и начнет завершать их
#
# recurse(1)                 #--> вывод: 1 2 3 4 4 3 2 1

# задача: Примеры использования рекурсии / факториал
# def fact(n):
#     if n <= 0:
#         return 1
#     else:
#         return n * fact(n - 1)
#
# print(fact(5))

# задача: проход каталога
# F = {
#     'C': {
#         'Python39': ['py.exe', 'python.ini'],
#         'Program files': {
#             'Java': ['Readme.txt', 'welcome.html', 'java.exe'],
#             'Matlab': ['matlab.bat', 'matlab.exe', 'mcc.bat']
#         },
#         'Windows': {
#             'System32': ['acl.dll', 'fasd.ddl', 'zip.ddl']
#         }
#     }
# }
#
# def get_files(path, depth=0):
#     for f in path:
#         print(' ' * depth, f)
#         if type(path[f]) == dict:
#             get_files(path[f], depth + 1)
#         else:
#             print(' ' * (depth + 1), ' '.join(path[f]))
#
#
# print(get_files(F))

# задача: фибоначи
# def fibonacci(n):
#     if n == 2:
#         return [1, 1]
#     else:
#         fib_sequence = fibonacci(n - 1)
#         fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
#         return fib_sequence
#
# result = fibonacci(5)
# print(*result)

# -------------------------------------------------------------------------------------------------------------------- #
# АНОНИМНЫЕ ФУНКЦИИ / LAMBDA

# лямбда функции - это функции, поэтому вызов их тоже через ()
# может быть записана как элемент любой конструкции языка питон

# задача: поделить а на b, если a или b = 0 вывести None
# get_div = lambda a, b: None if 0 in (a, b) else a / b
# print(get_div(0, 1))

# -------------------------------------------------------------------------------------------------------------------- #
# ОБЛАСТЬ ВИДИМОСТИ

# global   - ключевое слово, написав которые будет изменяться переменная объявленная в глобал области видимости, но
#            сами изменения будут записаны в локал области видимости (скажем в функции)
# nonlocal - то же самое, только это для локал области внутри другой локал области

# обращаться к локальным переменным вне функции - нельзя, но обращаться к глобальным переменным в теле функции - можно


# допустим есть программа myprog, для нее создается пространство имен
# когда мы объявляем в ней переменные, типа
# n = 3   #-->  это глобальная переменная (можно достучаться до нее  из любого места программы)

# а если, у нас есть функция func
# def func(lst):    #-->  то в пространстве имен созданным для func - будут новые переменные
#     for x in lst: #-->  lst, x, n - называются ЛОКАЛЬНЫМИ ПЕРЕМЕННЫМИ
#         n = x + 1
#         print(n)

# пример
# N = 100
# WIDTH, HEIGHT = 1000, 500
#
#
# def func(lst):
#     N = 20             #--> если убрать - будет работа с глобал N
#     for x in lst:
#         n = x + 1 + N  #--> сейчас будет идти работа с локальной N
#         print(n)
#
#
# func([1, 2, 3])

# обширный пример области видимости
# x = 0 # глобал переменная
#
# def outer():
#     x = 1                     #--> локал
#     def inner():
#         x = 2                 #--> выведет вот этот х первым 2
#         print('inner: ', x)
#
#     inner()
#     print('outer: ', x)       #--> потом этот 1
#
# outer()
# print('global: ', x)          #--> и потом этот 0

# добавим nonlocal
# x = 0                         #--> глобал переменная
#
# def outer():
#     x = 1
#     def inner():
#         nonlocal x            #--> сказали этим что x внутри этой области - это x из другой локальной области
#         x = 2                 #--> по сути как ссылка, что нужно изменять не этот х, а х повыше
#         print('inner: ', x)  #--> выведет 2
#
#     inner()
#     print('outer: ', x)       #--> выведет тоже два, тк был изменен в другой локал области из-за nonlocal
#
# outer()
# print('global: ', x)          #-->  останется тем же

# добавим global
# x = 0                         #--> глобал переменная

# def outer():
#     global x                  #--> сказали, что будет изменяться не этот x, а x, что находится в глобал области видимости
#     x = 1
#     def inner():
#         global x              #--> тоже самое
#         x = 2
#         print('inner: ', x)   #-->  везде х вернет 2
#
#     inner()
#     print('outer: ', x)
#
# outer()
# print('global: ', x)

# как создать глобальную переменную из локальной области видимости?
# def create_global(x):
#     global TOTAL
#     TOTAL = x

# -------------------------------------------------------------------------------------------------------------------- #
# ЗАМЫКАНИЯ

# на примере
# def say_name(name):
#     def say_goodbye():
#         print('By,', name)
#
#     return say_goodbye
#
# print(say_name('g'))      #-->  выведет <function say_name.<locals>.say_goodbye at 0x7f108f6c35b0>
# f = say_name('White')     #-->  определили переменную с ссылкой на объект, который хранит в себе выполнение функции say_goodbye
# f()                       #-->  выведет By, White

# каждая область видимости по сути имеет ссылку на области видимости постарше
# у say_goodbye - есть переменная name, ссылка на область видимости say_name, а у say_name есть ссылка на global (дефолт)

# все эти локальные ссылки существуют, только из-за существования ссылки f - если мы вызвали say_name и все, то все локал
# переменные бы удалились сборщиком мусора

# Эта конструкция ссылок называется ЗАМЫКАНИЕМ, почему?
# все из-за того, что у нас есть ссылка f (глобальная), которая ссылается на выполнение работы локал функции say_goodbye
# а та в свою очередь ссылается на чуть повыше локальную область say_name, через переменную name
# а say_name по дефолту ссылается на глобальную область видимости
# Ну вот и в итоге получается замкнутый круг - ЗАМЫКАНИЕ

# пример удаление ненужного из строки
# def strip_string(strip_chars=' '):
#     def do_strip(string):
#         return string.strip(strip_chars)
#
#     return do_strip
#
# str1 = strip_string()         #-->  создаем ссылку, которая будет держать в себе локал объект-функцию do_strip
# str2 = strip_string(' !?.,:') #-->  тоже самое, только дефолт параметры изменились
#
# print(str1('   hello!..  '))  #-->  для сохраненной ссылки строку
# print(str2(' hello!..   '))

# задача: добавить 2 к введенному числу
# def counter_add(n):
#     def plus_smth(k):
#         return n + k
#
#     return plus_smth
#
#
# k = int(input())
# cnt = counter_add(2)  #-->  при выполнении counter_add(2) - держит в return запуск plus_smth и так же СОХРАНЯЕТ значение k
# print(cnt(k))         #-->  как помним, k не удаляется тк, существует ссылка в глобал области (cnt), поэтому локал переменная k существует
                        #-->  далее к созданной ссылке cnt - дописываем (), что означает запуск сохраненный в return (запуск
                        #-->  ну и передаем еще туда аргумент k, тк функция plus_smth требует один аргумент (k)
                        #-->  а переменную n мы уже знаем из другой локал области

# задача: затегать строку
# def counter_add():
#     def counter_in(s):
#         return f'<h1>{s}</h1>'
#     return counter_in
#
# s = input()
#
# print(counter_add()(s))

# задача: обернуть строку в tp (по дефолту list)
# на вход
# list
# -5 6 8 11 0 111 -456 3
# def get_tp(tp='list'):
#     def get_lst(str):
#         return (tuple, list)[tp == 'list'](map(int, str.split())) # крутая фича
#     return get_lst
#
#
# cnt = get_tp(input())
# print(cnt(input()))

# -------------------------------------------------------------------------------------------------------------------- #
# ДЕКОРАТОРЫ

# смысл декоратора в том, чтобы сделать что-то до вызова функции и после
# Благодаря создаваемому замыканию функции func_decorator (декорированию) можно расширить функционал, которую мы хотим расширить

# декоратор должен обязательно возвращать функцию! В том числе и lambda-функцию
# те необязательно написание внутренней функции wrapper, на ее месте может быть lambda

# пример дефолтного декоратора
# def func_decorator(func):                                     #--> сюда передали some_func
#     def wrapper():
#         print('---------ЧТО-ТО ДО ВЫЗОВА ФУНКЦИИ---------')
#         func()
#         print('---------ЧТО-ТО ПОСЛЕ ВЫЗОВА ФУНКЦИИ---------')
#
#     return wrapper
#
#
# def some_func():
#     print('вызов some_func')
#
#
# f = func_decorator(some_func) #--> создается глобал ссылка f, которая запускает выполнение функции-декоратора func_decorator
# f()                           #--> которая хранит в return запуск функции wrapper, в которой вызывается основа - some_func
#                                 --> после отработки которой идет возврат обратно в декоратор, на завершение
#                                 --> а f() - это просто запуск этого дерьма


# f = func_decorator(some_func)         #--> обычно для удобства при декорировании тех или иных функции, создают не ссылку с названием f
# some_func = func_decorator(some_func) #--> а определяют такое же имя как и у функции

# Так как существует возможность того, что функции будут дописываться и изменяться, к примеру в нее могут передаваться новые
# параметры (в прошлом примере их вообще не было), то нужно писать что-то универсальное.

# УНИВЕРСАЛЬНЫЙ ДЕКОРАТОР
# def func_decorator(func):
#     def wrapper(*args, **kwargs):
#         print('---------ЧТО-ТО ДО ВЫЗОВА ФУНКЦИИ---------')
#
#         result = func(*args, **kwargs)                            #--> знакомые *args, **kwargs = вызов some_func h1
#                                                                   #--> print(args, kwargs) = ('вызов some_func', 'h1') {}
#         print('---------ЧТО-ТО ПОСЛЕ ВЫЗОВА ФУНКЦИИ---------')
#         return result                                             #--> дописали return
#
#     return wrapper
#
#
# def some_func(title, tag):                                        #--> передаем сколько хотим параметров
#     print(f'title = {title}, tag = {tag}')
#     return f'<{tag}>{title}</{tag}>'                              #--> дописали return
#
#
# some_func = func_decorator(some_func)
# result = some_func('вызов some_func', 'h1')
#
# print(result)                                                    #--> выведет <h1>вызов some_func</h1>

# А ТЕПЕРЬ ТО КАК НУЖНО ПИСАТЬ ДЕКОРАТОРЫ))

# задача: вычислить площадь треугольника
# def func_show(func):
#     def wrapper(*args, **kwargs):
#         result = func(*args, **kwargs)
#         print(f"Площадь прямоугольника: {result}")
#     return wrapper
#
#
# @func_show                    #--> look here
# def get_sq(width, height):
#     return width * height
#
#
# get_sq(8, 11)                 #--> как тут видно, не нужно больше создавать переменных-ссылок на декоратор, внутри
                                #--> которого передаешь функцию. А просто вызываешь функцию и она цепляет декоратор из-за @ над ней


# задача: создать меню из строки
# def show_menu(func):
#     def wrapper(*args, **kwargs):
#         for i, j in enumerate(func(*args, **kwargs), start=1):
#             print(f'{i}. {j}')
#     return wrapper
#
# @show_menu
# def get_menu(s):
#     return s.split()
#
#
# get_menu('Главная Добавить Удалить Выйти')

# задача: отсортировать список, поступает строка (пример декоратора с лямбдой)
# def sort_list(func):
#     return lambda *args, **kwargs: sorted(func(*args, **kwargs))
#
#
# @sort_list
# def get_list(s):
#     return s.split()
#
#
# print(*get_list('1 -2 3 4'))

# задача: превратить из 'Python - это круто!' --> python-eto-kruto!
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
#
# def remove(func):
#     def wrapper(*args, **kwargs):
#         ls = func(*args, **kwargs).replace('-', ' ').split()
#         return '-'.join(ls)
#     return wrapper
#
# @remove
# def convert(strings):
#     # t.get(i, i) - пытается взять из словаря t значение t[i] если оно есть, если нет - вернет значение i
#     lst = [t.get(i, i) if i not in [":", ";", '.', ',', ' '] else '-' for i in strings.lower()]
#     return ''.join(lst)
#
# print(convert('Python - это круто!')) #--> res = python-eto-kruto!

# ПЕРЕДАЧА АРГУМЕНТОВ ДЕКОРАТОРУ
# задача: вычислить производную функции с возможностью задавать точность шага
# import math
#
#
# def df_decorator(dx=0.01):       # --> по дефолту точность шага 0.01
#     def func_decorator(func):
#         def wrapper(x, *args, **kwargs):
#             dx = 0.0001
#             res = (func(x + dx, *args, **kwargs) - func(x, *args, **kwargs)) / dx
#
#             return res
#         return wrapper
#     return func_decorator
#
#
# # @df_decorator(dx=0.0000000001)  # -->  теперь при использовании декоратора - можно менять передаваемый аргумент
# def sin_df(x):
#     return math.sin(x)
#
#
# # если представить это в старом виде, без @
# f = df_decorator(dx=0.001)                #--> хранит func_decorator
# sin_df = f(sin_df) # хранит wrapper       #--> далее декорируем нашу функцию sin_df, вызывая f

# # sin_df = df_decorator(dx=0.001)(sin_df) #--> или можно записать в одну строку
# df = sin_df(math.pi / 3)                  #--> вызывается декорированная функция df
# print(df)

# КАК СОХРАНЯТЬ ИМЯ ФУНКЦИИ ПРИ ДЕКОРИРОВАНИИ
# import math
# from functools import wraps   #-->  look here
#
#
# def df_decorator(dx=0.01):
#     def func_decorator(func):
#
#         # если не написать этот декоратор (@wraps(func)), то при запросе sind_df.__doc__
#         # будет выдавать wrapper, тк это последняя функция на которой остановился алгоритм
#         # чтобы не терять имя функции sind_df или ее документации -> используют декоратор @wraps
#
#         @wraps(func)
#         def wrapper(x, *args, **kwargs):
#             res = (func(x + dx, *args, **kwargs) - func(x, *args, **kwargs)) / dx
#
#             # старая форма записи, эквивалентно ->  @wraps(func)
#             # wrapper.__name__ = func.__name__
#             # wrapper.__doc__ = func.__doc__
#
#             return res
#         return wrapper
#     return func_decorator
#
#
# @df_decorator()                                     #--> есть возможность передавать параметры в декоратор
# def sind_df(x):
#     """Функция для вычисления производной синуса""" #--> документация, что хотим сохранить
#     return math.sin(x)
#
#
# df = sind_df(math.pi / 3)
# print(f'doc: {sind_df.__doc__} | name: {sind_df.__name__}\nПроизводная df: {df}')

# задача: просуммировать введенные значения, прибавить к ним 5 (прибавка должна происходить в передаваемых арг. декоратора)
# def decorator_get_list_summ(start):
#     def get_lst_summ(func):
#         def wrapper(*args, **kwargs):
#             return sum(func(*args, **kwargs)) + start
#
#         return wrapper
#     return get_lst_summ
#
#
# @decorator_get_list_summ(start=5)
# def get_lst(input_str):
#     return [int(i) for i in input_str.split()]
#
#
# get_lst = get_lst('5 6 3 6 -4 6 -1') # Вызов декорированной функции
# print(get_lst)

# -------------------------------------------------------------------------------------------------------------------- #
# МОДУЛИ И ПАКЕТЫ / IMPORT / PIP

# 1. Импорт создает пространство имен в глобальной области видимости, через которое мы можем обращаться к глобальным
#    определениям в соответствующем модуле
# 2. Если происходит импорт модуля, то он отрабатывает один раз!
# 3. Лучше всего импортировать в виде from ... import ..
# 4. from .. python import get_python --> .. - означает перейти к родительскому каталогу

# print(locals())     #--> вывод всех локальных объектов

# program 1
# import mymodule     #--> при запуске этой программы - будет выполнена один раз программа mymodule

# program: mymodule
# def floor():
#     pass
#
# print(__name__)     #--> те вот это выведется на экран ( и будет равно mymodule)

# но если запустить программу mymodule - то print(__name__) будет равно __main__
# поэтому часто пишут мини проверку:

# if __name__ == '__main__':    #--> отработка через мейн программу
#     print('main program')
# else:
#     print('import run')       #--> запуск был через импорт

# pip list                      #--> узнать список пакетов

# пакетная установка модулей:
# pip install -r <текстовый файл>, в файле пишешь все пакеты, что нужно установить, к примеру numpy==1.19.0

# pip freeze > requirements.txt #--> сохранить все пакеты, что есть в проекте

# ИМПОРТ ПАКЕТОВ
# допустим, мы создали пакет courses, в котором есть файлы html.py, java.py, python.py
# так же, при создании пакета courses --> автоматически создается файл __init__.py
#
# при импортировании пакета courses в какой-либо программе, файл __init__.py будет вызван первым и передаст все
# что там есть, поэтому:
#
# в __init__.py нужно написать импорты файлов html.py, java.py, python.py, если мы хотим чтобы они тоже цеплялись при
# импортировании пакета courses

# допустим у нас есть такой импорт:
# from courses.python import get_python  --> если абсолютный путь изменится - импорт зафейлится

# можно написать импорт вот так, и он будет универсальным:
# from .python import get_python --> где точка означает, что мы обращаемся к текущему пакету

# так же можно делать, если мы хотим импортировать сразу несколько файлов:
# from . import html, java, php, python --> импорт сделан на уровне модулей

# * не одобряется при импортировании модулей, но при импортировании пакетов - это ок, тк они постоянно дописываются
# from .python import *

# фишка еще в том, что звездочку можно контролировать, те сказать, точно что должно импортироваться, если
# кто-то использует *

# к примеру, у нас есть файл php в пакете courses. В файле php.py есть две функции

# php:
#       __all__ = ['get_php']  --> разрешаем импортировать только get_php при *
#     def get_php():
#         pass
#
#     def get_mysql():
#         pass

# в пакете, где файл php есть файл __init__.py, в нем:
# from .php import *

# в другой программе:
#     import courses
#
#     courses.get_php() --> все гут
#     courses.get_mysql() --> все плохо, тк он не описан в __all__

# -------------------------------------------------------------------------------------------------------------------- #
# ФУНКЦИЯ OPEN / ЧТЕНИЕ ДАННЫХ ИЗ ФАЙЛА

# примеры отсюда раскоменчивать по очереди, тк если разом - каретка будет уходить и файл не будет читаться

# file = open('/home/hoopma/PycharmProjects/Python_theory_2/my_file')
#
# print(file.read(4))             #--> прочитает 4 символа
# print(file.read(2))             #--> прочитает еще два символа (если до этого был вызван file.read(4)
# file.seek(0)                    #--> говорим, что файловый указатель будет стоять в начале
# print(file.read())              #--> прочитает весь файл
# print(file.tell())              #--> возвращает текущую файловую позицию (utf-8 берет за 1 значение 2 байта)
# print(file.readline())          #--> ничего не прочитает, если каретка стоит в конце файла
# print(file.readline(), end='')  #--> выведет первую строку
#
# for line in file:               #--> прочитать весь файл тк файл итерируемая штука
#     print(line, end='')
#
# print(file.readlines())         #-->  если хотим получить прочитанный файл в виде списка
# file.close()                    #--> после работы с файлом, его нужно обязательно закрыть!
#                                 #--> при это происходит освобождение памяти выделенное под этот файл и еще данные не потеряются
#
# FileNotFoundError --> Не верный путь к файлу по какой-либо причине
# это обзор как работает, но пишут немного по другому, покороче
# try:
#     file = open('/home/hoopma/PycharmProjects/Python_theory_2/my_file')   #--> пытаемся открыть файл
#     try:                                                                  #--> так как в этом блоке нет except - пойдет на уровень выше
#         s = file.readlines()          #--> пытаемся прочитать строки      #--> в поисках другого обработчика исключений
#         int(s)                        #--> намеренная ошибка, для демонстрации
#         print(s)
#     finally:
#         file.close()                  #--> выполнится в любом случае, даже если будет ошибка
# except FileNotFoundError:             #--> конкретный except - будет вызван, если нельзя открыть
#     print('Невозможно открыть файл')
# except:                               #--> общий except - будет вызван, если будет какая-либо ошибка (кроме FileNotFoundError)
#     print('Ошибка при работе с файлом')

# МЕНЕДЖЕР КОНТЕКСТА WITH

    # это аналог того, что выше, только короче (тут включено открытие файла, блок try и блок finally (закрытие файла))
    # блок with автоматически закрывает файл

# try:
#     with open('/home/hoopma/PycharmProjects/Python_theory_2/my_file') as file:
#         s = file.readlines()
#         print(s)
#
# except FileNotFoundError:
#     print('Невозможно открыть файл')
# except:
#     print('Ошибка при работе с файлом')

# ЗАПИСЬ В ФАЙЛ
    #--> режимы: w - запись, a - append
    #--> если стоит режим 'a' или 'w', то файл уже нельзя будет читать, только записывать
    #--> если хотим, чтобы записывало и читало, то a+ или w+

# file = open('/home/hoopma/PycharmProjects/Python_theory_2/filte_for_write', 'w')
# file.write('hello') #--> запишет hello (перезапишет все что там было до него)
# file.close()        #--> всегда закрываем файл!

# try:
#     with open('/home/hoopma/PycharmProjects/Python_theory_2/filte_for_write', 'w') as file:
#         file.write('hi') #--> запись
#
# except:
#     print('Ошибка при работе с файлом')

# try:
#     with open('/home/hoopma/PycharmProjects/Python_theory_2/filte_for_write', 'a+') as file:
#         #--> тк файл сейчас открыт в режиме a+ - означает что каретка находится в конце файла те для чтения ее нужно
#         #--> будет вернуть в начало

#         file.seek(0)
#         file.write('hi')                  #--> как видно отсюда запись будет идти не в начало, а в конец
#                                           #--> это говорит о том что существуют две каретки: для чтения и записи
#         print(file.readlines())
#         file.write('hi')
#
#         file.writelines(['k1k\n', 'k2k'])
#         print(file.readlines())
#
# except:
#     print('Ошибка при работе с файлом')

# ПРИМЕР КАК ЗАПИСЫВАТЬ В ФАЙЛ В НУЖНОМ ДЛЯ РАБОТЫ ВИДЕ (типа у нас был список и запишет именно файл)
# import pickle
#
# books = [
#     ('Евгений Онегин', 'Пушкин', 200),
#     ('Муму', 'Тургенев', 250)
# ]
#
# file = open('out.bin', 'wb')  #--> wb - запись в бинарном режиме
# bs = pickle.dump(books, file) #--> запись того что хотим, куда мы хотим (запишет в бинарном виде)
# file.close()
#
# file = open('out.bin', 'rb')  #--> rb - чтение в бинарном режиме
# bs = pickle.load(file)
# file.close()
# print(bs)                     #--> [('Евгений Онегин', 'Пушкин', 200), ('Муму', 'Тургенев', 250)]

# -------------------------------------------------------------------------------------------------------------------- #
# ВЫРАЖЕНИЯ ГЕРЕРАТОРЫ

# Генератор не хранит сам по себе весь лям значений, а в моменте хранит только одно

# простой пример:
# b2 = (int(i) for i in ['1', '2', '3', '4', '5'])
# for i in b2:
#     print(i)

# задача: зациклить вывод списка на определенный интервал
# cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
# gen = (cities[i % len(cities)] for i in range(1_000_000))  #--> тут мы говорим, что генератор способен вывести 1 лям значений
# print(*(next(gen) for _ in range(50)))                     #--> вывод генератора

# задача: вычислить функцию на определенном интервале
# import numpy as np
# a, b = list(map(int, input().split()))                       #--> arange только для того, чтобы задать float шаг
# val = lambda x: 0.5 * pow(x, 2) - 2.0
# gen = (val(i) for i in np.arange(a, b, 0.01))                #--> плюс  тут в том, что будет храниться не сразу весь диапазон
# print(*(round(next(gen), 2) for _ in np.arange(a, b, 0.01))) #--> а только 1 значение из диапазона

# gen = map(lambda i, j: int(i) * int(j), input().split(), input().split())
# print(*(next(gen) for _ in '1234'))   #--> '1234' - означает, что будет браться 4 элемента, с тем же успехом можно было
#                                       #--> поставить abcd или range(4)

# -------------------------------------------------------------------------------------------------------------------- #
# ФУНКЦИЯ ГЕНЕРАТОР

# функция становится генератором, если в ней используется YIELD

# Принципиальные отличия функции-генератора от обычной функции:
#     1. при повторном вызове предыдущие значения внутренних переменных не обнуляются
#     2. при повторном обращении - выполнение продолжается со строки yield
#     3. внутри тела основной программы лучше привязать переменную к функции-генератору и обращаться через нее
#     4. фактически тот же генератор только имеет def и "return"(yield) как функция.
# Если return-возвращаться, то yield-урожай,  т.е. прием промежуточных значений.
# Удобно пользоваться бесконечным циклом внутри ф-г.

# обычная функция, отработает после встречи первого return
# def get_list():
#     for i in range(5):
#         return i

# print(get_list())

# у функции генератора, при запуске будет храниться генератор-object, тем самым дает нам возможность итерироваться по нему
# def get_list():
#     for i in [1, 2, 3, 4]:
#         yield i         #--> yield - возвращает текущее состояние i, замораживает все локал переменные до следующего вызова
#
#
# gen = get_list()
# for i in gen:           #--> итерируемся по значениям, которые можем получить в gen
#     print(i)

# задача: поиск среднего значения в диапазоне
# import statistics as s
#
# def get_avg(a, b):
#     for i in range(a, b):
#         yield s.mean(list(range(a, b - i + 2)))
#
#
# a, b = list(map(int, input().split()))
# gen = get_avg(a, b)
#
#
# print(list(gen)) #--> вывод всех значений генератора в list

# задача: сгенерировать n кол-во паролей
# from random import seed, randint
# from string import ascii_lowercase, ascii_uppercase
#
# seed(1)
#
#
# def get_password(n):
#     while True:
#         chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
#         yield ''.join([chars[randint(0, len(chars)-1)] for _ in range(n)])
#
#
# n = int(input())
# gen = get_password(n)
# [print(next(gen)) for _ in range(5)]

# задача: вернуть простые числа
# import sympy
#
#
# def get_natural_value():
#     i = 2
#     while True:
#         yield sympy.prime(i)
#         i += 2
#
#
# gen = get_natural_value()
# print(*(next(gen) for _ in range(20)))

# -------------------------------------------------------------------------------------------------------------------- #
# ITERABLE / ITERATOR

# iterable - что-то итерируемое, и собственно итератор-протокол
# итератор-протокол означает, что объект должен уметь реализовать два метода __iter__ и __next__
# если у переменной есть только метод __iter__, то это iterable, если еще и __next__, то это iterator,
# чтобы реализовать итератор, нужно создать класс в котором будет переопределен __iter__ и _next__
#
# numbers = [1, 2, 3, 4, 5]
# for num in numbers:
#     print(num**2)
#
# # посмотреть какие методы и атрибуты есть у iterable object
# print(dir(numbers))
#
# # хотим узнать к чему относится numbers
# my_numbers = numbers.__iter__()
# print(my_numbers) # <list_iterator object at 0x7826c8e5faf0>


# -------------------------------------------------------------------------------------------------------------------- #
# ЧЕМ ОТЛИЧАЕТСЯ ИТЕРАТОР ОТ ГЕНЕРАТОРА

# генератор - это более удобный способ реализовать итератор
# пример своего итератора:
# class StringUpper:
#     def __init__(self, string):
#         self.string = string
#         self.str_len = len(string)
#         self.position = 0
#
#     def __iter__(self):
#         return self
#
#     def __next__(self):
#         if self.position < self.str_len:
#             letter = self.string[self.position]
#             self.position += 1
#             return letter.upper()
#         raise StopIteration
#
# for letter in StringUpper('Hello world'):
#     print(letter)
#
# # пример генератора
# def string_upper(string):
#     for letter in string:
#         yield letter.upper()
#
# for i in string_upper('Hello world'):
#     print(i)

# вывод - все ахуенно короче

# -------------------------------------------------------------------------------------------------------------------- #
# ФУНКЦИЯ MAP

# map(function, iter)
# map возвращает iter-object по которому можно пройтись только ОДИН РАЗ те он как генератор

# b1 = map(int, ['1', '2', '3', '4', '5'])          #--> b1 эквивалентно b2
# b2 = (int(i) for i in ['1', '2', '3', '4', '5'])  #--> генератор

# задача: записать в виде [['l', 'o', 'l'], ['k', 'e', 'k'], ['g', 'o', 'd']]
# cities = ['LOL', 'kek', 'god']
# b = map(lambda s: list(s.lower()), cities)        #--> использование lambda
# print(list(b))

# задача: записать в виде [[8, 11, -5], [3, 4, 10], [-1, -2, 3], [4, 5, 6]]
# lst_in = ['8 11 -5', '3 4 10', '-1 -2 3', '4 5 6']
# m = list(map(lambda x: list(map(int, x.split())), lst_in))                #--> два map
# print(m)

# lst_in = ['8 11 -5', '3 4 10', '-1 -2 3', '4 5 6']
# m = [[*map(int, x.split())] for x in lst_in]                              #--> map()  в генераторе
# print(m)

# задача:
# s = 'house=дом car=машина men=человек tree=дерево'
# s_lst = s.split()
# print(s_lst)
# tp = map(lambda x: tuple(x.split('=')), s_lst)
# print(tuple(tp))

# задача: Преобразовать строку 'Привет Питон' в 'privet-piton'
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# m = map(lambda x: t.get(x.lower(), '-'), input()) #--> берет из таблицы значение, если его нет = '-'
# print(''.join(m))

# в map можно использовать второй аргумент несколько раз , лямбда будет выполняться по очереди, для каждого из списков
# gen = map(lambda i, j: int(i) * int(j), input().split(), input().split())
# print(*(next(gen) for _ in '1234'))   #--> '1234' - означает, что будет браться 4 элемента, с тем же успехом можно было
#                                       #--> поставить abcd или range(4)

# -------------------------------------------------------------------------------------------------------------------- #
# ФУНКЦИЯ FILTER

# filter(function, iter)
# тоже iter-object
# если при выполнении функции - True значение вернется, если False - ничего не вернет и пойдет дальше

# задача: вывести только четные значения
# lst = [1, 2, 3, 4, 5, 6]
# f = filter(lambda x: x % 2 == 0, lst)
# print(*f)
# print(f)

# задача: вернуть простые числа
# def get_simple_value(x):
#     d = x - 1
#     if d < 0:
#         return False
#
#     while d > 1:
#         if x % d == 0:
#             return False
#         d -= 1
#
#     return True
#
# lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# f = filter(get_simple_value, lst)
# print(*f)

# задача: вернуть простые нечетные числа
# def get_simple_value(x):
#     d = x - 1
#     if d < 0:
#         return False
#
#     while d > 1:
#         if x % d == 0:
#             return False
#         d -= 1
#
#     return True
#
# lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# f = filter(get_simple_value, lst)
# f2 = filter(lambda x: x % 2 != 0, f)   #--> можно так делать тк второй аргумент filter - итерируемый объект, а
# print(*f2)                             #--> а filter сам по себе итерируемый объект, получается фильтр в фильтре

# задача: для введенных чисел (две строки) вывести те, что присутствуют в обоих вводах и только четные
# s1, s2 = map(set, [[int(i) for i in input().split()] for i in range(2)])
# print(*sorted(list(filter(lambda x: x % 2 == 0, s1.intersection(s2)))))

# -------------------------------------------------------------------------------------------------------------------- #
# ФУНКЦИЯ ZIP

# a = [1, 2, 3, 4, 5]          #--> совместит два этих списка по вертикали. Когда один список заканчивается, а другой нет -
# b = [1, 2, 3, 4, 5, 6, 7]    #--> зип стопает выполнение
# print(*zip(a, b))            #--> (1, 1) (2, 2) (3, 3) (4, 4) (5, 5)

# можно зипать не только списки, но и список со строкой
# a = [1, 2, 3, 4, 5]
# s = 'python'
# print(*zip(a, s))            #--> (1, 'p') (2, 'y') (3, 't') (4, 'h') (5, 'o')

# -------------------------------------------------------------------------------------------------------------------- #
# СОРТИРОВКА / SORT / SORTED

# Алгоритм быстрой сортировки через рекурсию
# def quick_sort(arr):
#     if len(arr) <= 1:
#         return arr
#     pivot = arr[len(arr) // 2]
#     lesser = [x for x in arr if x < pivot]
#     equal = [x for x in arr if x == pivot]
#     greater = [x for x in arr if x > pivot]
#     return quick_sort(lesser) + equal + quick_sort(greater)
#
#
# print(quick_sort([1, 2,5, 2, 5, 1345,1 ,2, 67, 97, 141,987,3,134, 4, 5]))

# SORT / SORTED
# Отличие sort и sorted в том, что sorted применяется к любым итерируемым объектам, а sort нет.
# sort может применяться только к изменяемым типам данных
# sort - не создает новый список, sorted - создает


# фишка в том, что отсортировался тот же список (новый не создавался)
# lst = [4, 3, -10, 7, 11, 6]
# lst.sort()                  #--> если присвоить переменной это - будет None
# lst.sort(reverse=True)      #--> сортировка по убыванию
# print(lst)

# если же нам новый отсортированный список, а старый оставить неизменным - sorted
# lst = [4, 3, -10, 7, 11, 6]
# print(sorted(lst))          #--> тут уже вернет не None, а отсортированный список (новый)

# СОРТИРОВКА С KEY
# при использовании sort или sorted можно использовать key, в котором будем говорить как именно будет сортироваться
# список (передавая в key какую либо функцию)

# задача: отсортировать и вывести только четные, если не четные + сотка
# def key_sort(x):
#     return x if x % 2 == 0 else 100 + x
#
# a = [4, 3, -10, 1, 7, 12]
# b = sorted(a, key=key_sort)
# print(b)

# # задача: отсортировать по кол-ву символов
# cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
# sorted_cities = sorted(cities, key=len, reverse=True)
# print(sorted_cities)
#
# # задача: отсортировать по первому символу
# sorted_cities = sorted(cities, key=lambda x: x[0])
# print(sorted_cities)
#
# # задача: отсортировать значения по правильному списку
# lst_in = ['Атос=лейтенант', 'Портос=прапорщик', "д'Артаньян=капитан", 'Арамис=лейтенант', 'Балакирев=рядовой']
# rank_order = ['рядовой', 'сержант', 'старшина', 'прапорщик', 'лейтенант', 'капитан', 'майор', 'подполковник', 'полковник']
# lst = [i.split('=') for i in lst_in]
# lst.sort(key=lambda x: rank_order.index(x[1]))
# print(lst)

# -------------------------------------------------------------------------------------------------------------------- #
# ISINSTANCE / TYPE

# есть два типа проверок isinstance() - не строгая и type() - строгая

# в чем отличие?
# b = True                    #--> и то, и то будет True тк в isinstance как то участвует наследование
# print(isinstance(b, int))   #--> (класс bool наследуется от int, поэтому выводит True)
# print(isinstance(b, bool))
#
# если использовать type - строгую проверку
# print(type(b) is bool) # True
# print(type(b) is int)  # False

# можно еще проверять на несколько типов сразу
# b = True
# print(type(b) in (int, float, bool))
# print(isinstance(b, (int, float)))

# задача: просуммировать все целочисленные значения, те проверить целочисленные ли они
# data = (4.5, 8.7, True, 'book', 8, 10, -11, [True, False])
# print(sum(filter(lambda x: type(x) is float, data)))
#
# # задача: вернуть только список с целочисленными значениями
# def get_list_dig(c):
#     return [x for x in c if type(x) in (float, int)]
#
#
# print(get_list_dig([1, 2, '3']))
#
# # -------------------------------------------------------------------------------------------------------------------- #
# ОПЕРАТОР IS И СРАВНЕНИЕ ОБЪЕКТОВ. В ЧЕМ РАЗНИЦА?
# a = 5
# b = 5

# # Оператор сравнения сравнивает именно значения объектов
# print(a == b) # True
#
# # is - сравнивает ссылки
# print(a is b)

# -------------------------------------------------------------------------------------------------------------------- #
# TRY / EXCEPT

# есть два типа ошибок - при компиляции, и в момент исполнения
# при компиляции - означает, что где-то неправильно написан код в плане местоположения, лишний отступ и тп
# в момент исполнения - это разного рода ошибки, с именами типа: ValueError

# try:
#     x, y = 1, 0
#     res = x / y
#
# # сначала прописываются блок со специализированными исключениями
# except FileNotFoundError:
#     print('первый except')
# except ZeroDivisionError:
#     print('второй except')
# except (FileNotFoundError, ZeroDivisionError):
#     print('общий except')
#
# # обширные исключения
# except Exception:
#     print('общий except')
#
# # отработает, если не было except
# else:
#     print('good')
#
# # будет отрабатывать всегда, даже если будет except
# finally:
#     print('Буду отрабатывать всегда, даже если будет except')
#
# # даже если отработал except программа будет работать дальше
# print('END')

# -------------------------------------------------------------------------------------------------------------------- #
# RAISE
# raise принудительно вызывает исключение. Можно вызвать только те, что наследуются от BaseException
# raise ZeroDivisionError('деление на нул')

# -------------------------------------------------------------------------------------------------------------------- #
# ЗАДАЧКИ

# # 1. проверка на треугольник
# a, b, c = map(int, input().split())
# a, b, c = 8, 3, 12
# print(a < b + c and b < a + c and c < a + b)
#
# # 2. задать размерность квадратной матрицы (n) - заполнить главную диагональ единицами
# n = int(input())
# n = [[0] * n for i in range(n)]
# for i in range(len(n)):
#     n[i][i] = 1
#     print(*n[i])
#
# # 3. вывести кратные числа для введенного числа
# n = int(input())
# print(*[i for i in range(1, n) if n % i == 0], n)
#
# # 4. построить квадратную матрицу, где первая строка состоит из 0, вторая из 1 и тд
# n = 4
# [print(*[i for j in range(n)]) for i in range(n)]
#
# # 5. вывести значения из списка с шагом два
# print(*[float(i) for i in input().split()][::2])
#
# # 6. сложить значения списков 1 и 2
# print([int(i) + int(j) for i in input().split()] for j in input().split())
#
# # 7. вводится четное кол-во чисел, к примеру 1 2 3 4 --> разбить их на пары в списке [['1', 2], ['3', 4]]
# n = input().split()
# print([[n[i], int(n[i + 1])] for i in range(0, len(n), 2)])
#
# # 8. возвести в квадрат значения списка
# A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# print([[i**2 for i in row] for row in A])
#
# # 9. Есть список, в котором списки. Нужно преобразовать числа в списках в один единый и возвести в квадрат
# A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# print([[i**2 for i in row] for row in A])
#
# # 10. Транспонирование таблицы
# # варииант через numpy
# import numpy as np
# lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [5, 4, 3]]
# transposed = np.transpose(lst)
# for i in transposed:
#     print(*i)
#
# # вариант через zip
# print(*zip(*lst))
#
# # 11. форматирование номера +7(912)123-45-67 в 8(912)1234568
# s = '+7(912)123-45-67'.replace('-', '').replace('+', '').replace('7', '8')
# print(s)
#
# # 12. поиск введенного слова в двумерном списке
#
# # 13. проверка на палиндром
# s = input().split()
# print('DA' if s == s[::-1] else 'NO')
#
# # 14. Проверка делится ли число m на n нацело
# m, n = [int(i) for i in input().split()]
# if m % n == 0:
#     print(m / n)
# else:
#     print(f'{m} на {n} нацело не делится')
#
# # 15. проверка на катеты в треугольнике
# # a, b, c = [int(i) for i in input().split()]
# # if c**2 == a**2 + b**2:
# #     print('ДА')
# # else:
# #     print('НЕТ')
#
# # 16. проверка есть ли указанные буквы в строке
# print(('NO', 'YES')[{*'hot'}.issubset(str)])
#
# # 17. проверка на счастливый билет
# num = [int(i) for i in input()]
# print(('НЕТ', 'ДА')[sum(num[:3]) == sum(num[-3:])])
#
# # 18. вывод минимального числа из списка
# # print(sorted([int(i) for i in input().split()])[0])
#
# # 19. ряд фибоначи
# fib1 = fib2 = 1
# n = int(input())
# print(fib1, fib2, end=' ')
# for i in range(2, n):
#     fib1, fib2 = fib2, fib1 + fib2
#     print(fib2, end=' ')
#
# # 20. вывести делители введенного числа
# n = int(input())
#
# for i in range(1, n + 1):
#     if n % i == 0:
#         print(i, end=' ')
#
# # 21. является ли вводимое число простым числом? (делится только на себя и на 1)
# n = int(input())
# res = True
# for i in range(2, n):
#     if n % i == 0:
#         res = False
#         break
# if res:
#     print('ДА')
# else:
#     print('НЕТ')
#
# # 23. продублировать значения в списке
# print(*[f'{i} {i}' for i in input().split()])
#
# # 24. заменить все отрицательные числа в списке на -1
# n = [-1.0 if '-' in i else float(i) for i in input().split()]
#
# # 25. # вводимый список городов вывести в столбик
# print('\n'.join([i for i in input().split()]
#
# # 26. создать матрицу с указанным размером, последний столбец сделать пятерками
# n = 5
# lst = [[1] * n] * n
# lst[0][-1] = 5      # это работает для всех подходящих варико, значит поменяется везде
# for i in lst:
#     print(*i)
#
# # 27. является ли матрица симметричной? см диагональ
# lst = [[1, 3, 4, 5, 6], [3, 1, 7, 8, 9], [4, 7, 1, 0, 4], [5, 8, 0, 1, 1], [6, 9, 4, 1, 1]]
# print(('НЕТ', 'ДА')[list(map(sum, zip(*lst))) == [sum(i) for i in lst]])
#
# # 28. минимальное кол-во валюты, которое потребуется для набора числа
# lst = [64, 32, 8, 4, 2, 1]
# n = 221
#
# for i in lst:
#     if i <= n:
#         div, n = divmod(n, i)        # div - целое / mod - частное
#         # print(div, n)
#         print(f'{i} ' * div, end='')
#
# # 29. Пока не встретится "стоп-слово", в данном случае q - будет продолжаться выполнение функции
# s = set(iter(input, 'q'))
# print(s)
#
# # 30. Cравнение поступаемых строк
# print(('НЕТ', 'ДА')[set(input().split()) == set(input().split())])
#
# # 31. Есть есть двойки - НЕ ДОПУЩЕН
# print(('НЕ ДОПУЩЕН', 'ДОПУЩЕН')[2 not in {int(i) for i in input().split()}])
#
# # 32. Проверка правильный ли мейл sc_lib@list.ru
# import string
# n = set(input())
# valid = set(string.ascii_letters + string.digits + '@' + '.' + '_')
# print(('НЕТ', 'ДА')[n.issubset(valid)])
#
# # 33. Наибольший общий делитель (НОД)
# from math import gcd
# def get_nod(a, b):
#     return gcd(a, b)
#
# print(get_nod(*[int(i) for i in input().split()]))
#
# # 34. Проверка пароля на длину и спец символы
# def check_password(str, chars='$%!?@#'):
#     return len(str) >= 8 and any(c in chars for c in str)
# print(check_password('12345678!'))
#
# # 34. Как проверить время выполнения кода
# import timeit
# code1 = '''def check_password(str, chars='$%!?@#'):
#     return len(str) >= 8 and any(c in chars for c in str)
# print(check_password('12345678!'))'''
# code2 = '''def check_password(str, chars='$%!?@#'):
#     return len(set(str).intersection(chars)) > 0 and len(str) >= 8
# print(check_password('12345678!'))'''
#
# time1 = timeit.timeit(code1, number=1000)/100
# time2 = timeit.timeit(code2, number=1000)/100
# print(time1, time2)
#
# 35. Перезаписать введенное предложение транслитом, сепарируя чем мы хотим, по дефолту '-'
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# def convert(str, sep='-'):
#     lst = [t[i] if i in t else i for i in str]
#     return ''.join(lst).replace(' ', sep)
#
# str = input().lower()
# print(convert(str))
# print(convert(str, sep='+'))
#
# 36. Поиск максимального слова по длине
# def get_biggest_city(*args):
#     return max(args, key=len) # к каждому элементу списка будет применена функция len и по полученным значениям уже
#                               # будет искаться максимальное значение
#
# print(get_biggest_city(*input().split()))
#
# 37. Проверка на то, что единицы изолированы от других единиц, вокруг должны быть только нули
# def verify(table):
#     for i in range(len(table)):
#         for j in range(len(table[i])):
#             if table[i][j] == 1 and not is_isolate(table, i, j):
#                 return False
#     return True
#
# def is_isolate(table, row, col):
#     directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, -1), (-1, 1)]  # Возможные направления соседних элементов
#     for dx, dy in directions:
#         new_row = row + dx
#         new_col = col + dy
#         if 0 <= new_row < len(table) and 0 <= new_col < len(table) and table[new_row][new_col] == 1:
#             return False
#     return True
#
# table = [[1, 0, 0, 0, 0],
#          [0, 0, 0, 0, 1],
#          [0, 0, 0, 0, 0],
#          [0, 0, 0, 0, 0],
#          [1, 0, 1, 0, 1]]
#
# result = verify(table)
# print(result)
#
# 38. проверка мейлов
# import re
# pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
#
# s = input().split()
# f = filter(lambda x: re.match(pattern, x), s)
# print(*f)
# -------------------------------------------------------------------------------------------------------------------- #


# def get_first_matching_object(predicate, elements=None):
#     if elements is None:
#         elements = []
#
#     matching_objects = (elem for elem in elements if predicate(elem))
#     if matching_objects:
#         next(matching_objects)
#
#     else:
#         return None
#
# def temp(a):
#     return type(a) == int
#
# d = get_first_matching_object(temp, [1, '2', '3'])
# print(d)


# x = 1
# def gg(var):
#     var = x
#     var += 1
#     print(var)
#
# print(x)
#
# gg(x)
#
# lst = [1, 2, 3]
#
# def gg(var):
#     var = lst
#     var[0] = 100
#     print(var)
#     return var
#
# print(lst)
#
# lst = gg(lst)
#
#
# def get_first_matching_object(predicate, objects=None):
#     # if objects is None:
#     #     elements = []
#
#     if objects is None:
#         objects = []
#
#     matching_objects = (obj for obj in objects if predicate(object))
#     if matching_objects:
#         object = matching_objects[0]
#         return object
#     else:
#         return None

# # можно ли добавить в сет
# t = (1, [], 3)
# print(t[1].append(0))
# print(t)
#
# # лист компр
# compr_l = [i for i in range(5) if i & 1 == 0]
# compr_s = {i for i in range(5) if i & 1 == 0}
# compr_d = {i: i ** 2 for i in range(5)}
# print(compr_d)
#
# # сравнение is и ==
# a = [1, 2, 3]
# b = [1, 2, 3]
#
# print(a == b) # True (сравнивает значение)
# print(a is b) # False (сравнивает ссылки)
#
# a = b = [1, 2, 3] # ведут на один объект
# print(a is b) # False


# # deep / shallow copy
# # bad copy:
# a = [1, [2]]
#
# b = a
# b.append(3)
# b[1].append(4)
#
# print(a) # [1, [2, 4], 3]
#
# # shallow:
# a = [1, [2]]
#
# b = copy.copy(a)
# b.append(3)
# b[1].append(4)
#
# print(a) # [1, [2, 4]]
#
# # deep:
# a = [1, [2]]
#
# b = copy.deepcopy(a)
# b.append(3)
# b[1].append(4)
#
# print(a) # [1, [2]]
#
# # еще способы для поверхностной копии
# a = [1, [2]]
#
# import copy.copy
# b = list(a)
# b = a[:]
# b = [i for i in a]
# b = a.copy()

# # Как работают операторы AND, OR, NOT? Что они возвращают?
# # not
# print(not []) # True
# print(not [1, 2, 3]) # False
#
# # and и or возвращают не бул, а сам объект
#
# # если первый операнд = True - возвращает второй операнд
# # если False - возвращает первый
# print([] and 123) # []
# print([1] and 123) # 123
#
# # у or наоборот, если первый - false - вернет второй
# # если true - вернет его
# print([] or 123) # 123
# print([1] or 123) # [1]

# # LEGB
# str = 'global'
#
# def outer():
#     str = 'enclosing' # если будет коммент будет искать в global
#
#     def inner():
#         str = 'local' # если будет коммент будет искать в enclosing
#         print(str)
#
#     inner()
#
# outer()

# # анотации типов
# def some(a: int) -> int:
#     return a ** 2
#
# print(some('a')) # подчеркивает ide
# print(some(1.4)) # подчеркивает, но схавает
# print(some(4)) # все гут

# # передача аргументов в функцию
# a = [1, 2, 3]
#
# def some(arg):
#     print(arg is a) # True
#     # доказываем тем самым, что по ссылке
#
# print(some(a))

# # Использование изм. типа в качетсве аргумента
# # когда пайтон читает код, доходит до сигнатуры функции some
# # и читает аргументы этой функции. Там есть пустой список.
# # Он вычисляет его не когда мы ее вызываем, а когда эта функция
# # подготавливается к выполнению
#
# # те когда он первый раз доходит до some - читает параметр,
# # запоминает его, и в последующем работает всегда с ним
# # те не будет создавать каждый раз, а только один
# def some(a=[]):
#     a.append(1)
#     return a
#
# print(some()) # положит в уже созданный a [1]
# print(some([])) # тк передаем пустой - берет именно его [1]
# print(some())   # неожиданное поведение [1, 1] тк использует дефолтный а
# print(some([]))
#
# # как избежать
# def some(a=None):
#     if a is None:
#         a = []
#
#     a.append(1)
#     return a

# Что такое *args и **kwargs?
# def some(*args, **kwargs):
#     print(locals())  # {'args': (1, 2, 3), 'kwargs': {'a': 4, 'b': 5, 'c': 6}}
#
# some(1, 2, 3, a=4, b=5, c=6)

# Что такое lambda функция?
# d = {
#     1: 3,
#     2: 2,
#     3: 3
# }
#
# print(max(d)) # выведет макс ключ
# print(max(d, key=lambda x: d[x])) # выведет макс значение

# # рекурсия и цикл
#
# def factorial(n):
#     if n == 1:
#         return n
#     else:
#         return n * factorial(n - 1)
#
# def factorial2(n):
#     num = 1
#     while n >= 1:
#         num *= n
#         n -= 1
#
#     return num
#
# print(factorial(5)) # 120
# print(factorial2(5))
#
# import sys
# print(sys.getrecursionlimit())
# sys.setrecursionlimit(2000)


# демонстрация методов объекта
# class Person:
#     def __init__(self, name):
#         self.name = name
#
#     def say_hi(self):
#         return print(f'hello, {self.name}')
#
# p = Person('Ararat')
# p.say_hi()

# демонстрация методов класса
# class Person:
#     work_place = 'My company'
#
#     @classmethod
#     def get_my_work_place(cls):
#         return cls.work_place
#
# print(Person.get_my_work_place())
#
# p = Person()
# print(p.get_my_work_place())

# демонстрация статического метода
# from datetime import datetime
#
# class A:
#     @staticmethod
#     def get_time():
#         return datetime.now()
#
# print(A.get_time()) # можно вызывать из класса
# a = A()
# print(a.get_time()) # можно из объектов класса

# доступ к приватному атрибуту
# class A:
#     __private = 1
#
# a = A()
# print(a._A__private) # 1
# a._A__private = 3
# print(a._A__private) # 3

# зачем нужен проперти
# class Person:
#     first_name: str
#     last_name: str
#
#     def __init__(self, first_name: str, last_name: str):
#         self.first_name = first_name
#         self.last_name = last_name
#
#     @property
#     def full_name(self):
#         return f'{self.first_name} {self.last_name}'
#
#     @full_name.setter
#     def full_name(self, value):
#         name_surname = value.split(' ')
#         self.first_name = name_surname[0]
#         self.last_name = name_surname[1]
#
# p = Person('Egor', 'Pshelkin')
# print(p.full_name)
#
# p.full_name = 'Name Surname'
# print(p.first_name)
# print(p.last_name)

# абстрактный класс
# from abc import ABC, abstractmethod
#
# class Animal(ABC):
#     @abstractmethod
#     def say_something(self):
#         pass
#
# # a = Animal() # error
#
# class Cat(Animal):
#     def say_something(self):
#         return f'Мяу'
#
# c = Cat() # создаст объект тк переопределен абстрактный метод


# сравнение str и repr
# class Cat:
#     def __init__(self, name):
#         self.name = name
#
#     # вызовется если нет str
#     def __repr__(self):
#         return f"Cat(name)='{self.name}"
#
#     # вызовется только он
#     def __str__(self):
#         return f"Cat(name)='{self.name}"
#
# c = Cat('Marsik')
# print(c)

# зачем нужен super
# class A:
#     def __init__(self, a):
#         self.a = a
#
# class B:
#     def __init__(self, a, b):
#         super().__init__(a)
#         self.b = b

# композиция и наследование
# class A:
#     pass
#
# # берем весь функционал A
# class B(A):
#     pass
#
# # берем нужную часть класса
# class D:
#     a = A()

# замыкание
# def add_number(a):
#     def add(b):
#         return a + b
#
#     return add
#
# # запомнит, что в a лежит 5
# add_five = add_number(5)
#
# print(add_five(3)) # выведет 8

# итератор из коллекции
# lst = [1, 2, 3]
# my_iter = iter(lst)
# print(next(my_iter)) # 1
# print(next(my_iter)) # 2

# несколько yeild
# def some():
#     yield 1
#     yield 2
#     yield 3
#
# # создаем объект генератора
# s = some()
# # стартуем, попадаем в 1 yield
# print(next(s)) # выведет 1, запомнит точку
# print(next(s)) # выведет 2, запомнит точку
# print(next(s)) # выведет 3


# def a():
#     yield 1
#     yield 1
#
# def b():
#     yield from a()
#     yield 2
#     yield 2
#
# b = b()
# for i in b:
#     print(i)




























